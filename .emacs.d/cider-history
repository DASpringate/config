;; -*- coding: utf-8-unix -*-
;; Automatically written history of CIDER REPL session
;; Edit at your own risk

("(logprint \"hello\")" "(apply str (conj [1 2 3] 4))" "(conj [1 2 3] 4)" "(apply str [1 2 3] 4)" "(apply str [1 2 3])" "(apply println [\"a\" \"b\"])" "(println [\"a\" \"b\"])" "settings/*verbose*" "(alter-var-root (var settings/*verbose*) (fn [x] false))" "(alter-var-root (var settings/*verbose*) #(false))" "settings/*verbose*" "settings/*logfile*" "(dorun (repeat 10 (myprint \"test tests tests aghgh\" true)))" "(doall (repeat 10 (myprint \"test tests tests aghgh\" true)))" "(doall (repeat 10 (myprint \"test tests tests\" true)))" "(doall 10 (repeat (myprint \"test tests tests\" true)))" "(doall (repeat (myprint \"test tests tests\" true) 10))" "(repeat (myprint \"test tests tests\" true) 10)" "\"hello\"" "(myprint \"hello again tester\" false)" "(myprint \"hello again tester\" true)" "(myprint \"hello again tester\")" "(clojure.string/replace (str (new java.util.Date)) #\"[: ]\" \"_\")" "(clojure.string/replace (str (now)) #\"[: ]\" \"_\")" "(clojure.string/replace (str (now)) #\"[: ]\" \" \")" "(str (now))" "(first (now))" "(now)" "(defn now [] (new java.util.Date))" "(myprint \"hello again 3\")" "(myprint \"hello again 2\")" "(myprint \"hello again\")" "(println \"hello\")" "(prntest \"testfile\")" "(prntest false)" "(prntest)" "java.io.PrintStream" "java.io.PrintWriter" "java.io.PrintStream." "(println \"hello\"
			    )" "(download-link 557)" "(download-link 556)" "(download-link 554)" "(download-link 555)" "(download-link 554)" "(download-link 555)" "(download-link 554)" "*out*" "(writer/write-csv \"data/csv/rm4.csv\" (parser/parse-csv r) settings/*first-cols*)" "(parser/revman-data r)" "(def r (review-data (download-link 4)))" "(parser/revman-data r)" "(parse/revman-data r)" "(:body r)" "(keys (:body r))" "(writer/write-csv \"data/csv/rm4.csv\" (:body r) settings/*first-cols*)" "(:body r)" "(writer/write-csv \"data/csv/rm4.csv\" (:body r) settings/*first-cols*)" "(keys r)" "(:content r)" "r" "(slurp \"data/rm5/rm4.rm5\")" "(writer/write-csv \"data/csv/rm4.csv\" (:content r) settings/*first-cols*)" "settings/*first-cols*" "(writer/write-csv \"data/csv/rm4.csv\" r settings/*first-cols*)" "r" "(def r (review-data (download-link 4)))" "(dl/download-all-rm5 4 5 2 \"data\" false true)" "(dl/download-all-rm5 4 5 2 \"data\" true false)" "(dl/download-all-rm5 4 5 2 \"data\" true true)" "(dl/download-all-rm5 4 4 2 \"data\" true true)" "(range 4 5)" "(range 4 4)" "rev-data" "settings/*wiley-base*" "(when true (println \"hello\") (println \"plums\"))" "(writer/create-dir \"helllo\")" "(download-rm5 6)" "*dat*" "(parse/revman-data *dat*)" "*dat*" "(.mkdir (java.io.File. \"hello\"))" "(spit \"hello/test1\" \"this is a test\")" "(.mkdir (java.io.File. \"hello\"))" "(.mkdir (File. \"hello\"))" "(.mkdir \"hello\")" "(println \"hello\")" "(def *out* (java.io.PrintWriter. System/out))" "(println \"hello\")" "*out*" "(println \"hello\")" "(write-file)" "(write-file *out*)" "(source println)" "System/out" "*out*" "(redir *out* (println \"hello\"))" "(prntest \"hello/you\")" "(t/testprint)" "(prntest \"hello/you\")" "(t/testprint)" "(count rev)" "(concat [1 2 3] [4 5 6] [7 8 9])" "(map :tag (:content (nth (:content comp) 3)))" "(:content (nth (:content comp) 3))" "(map :tag (nth (:content comp) 3))" "(nth (:content comp) 3)" "(map #(-> % :tag) (:content comp))" "(class comp)" "(first comp)" "(map #(-> % :content :tag) comp)" "(map :tag comp)" "comp" "(:content *subgroup*)" "(count (flatten (extract-comparison-data *comp* 0) ))" "(flatten (extract-comparison-data *comp* 0) )" "(extract-comparison-data *comp* 0) " "(extract-comparison-data *comp 0) " "(map :content (filter map? (:content *subgroup*)))" "(map keys (filter map? (:content *subgroup*)))" "(map :tag (filter map? (:content *subgroup*)))" "(map :tag (filter map? (:content *comp*)))" "(:tag (filter map? (:content *comp*)))" "(count (filter map? (:content *comp*)))" "(count (:content *comp*))" "(count *comp*)" "(count rev)" "rev" "(count (extract-all *comparisons*))" "(count (flatten (extract-all *comparisons*))) " "()" "(count (extract-all *comparisons*))" "(extract-all *comparisons*)" "(extract-comparison-data *comp* 0)" "(extract-comparison-data 0)" "(extract-subgroup-data *subgroup* 0 0 0)" "(extract-data-data *data* 0 0 0 0)" "(extract-data-data *data* 0 0 0)" "(extract-subgroup-data *subgroup* 0 0 0)" "(extract-data-data *data* 0 0 0)" "(extract-data-data *data** 0 0 0)" "(extract-subgroup-data *subgroup* 0 0 0)" "(data-type :DICH_DATA)" "(data-type *outcome*)" "(extract-comparison-data *comp* 0)" "(count (extract-outcome-data *outcome* 0 0))" "(extract-outcome-data *outcome* 0 0)" "(get-labels *outcome*)" "(take 5 (iterate inc 0))" "(take 5 (repeat 4))" "(extract-comparison-data *comp* 0)" "(match-tag *outcome* \"OUTCOME\")" "(map :tag (filter #(and (map? %) (match (:tag %) \"OUTCOME\")) (:content *comp*)))" "(map :tag (filter #(and (map? %) match (:tag %) \"OUTCOME\") (:content *comp*)))" "(name nil)" "(map :tag (filter #(match (:tag %) \"OUTCOME\") (:content *comp*)))" "(map :tag (filter (match (:tag %) \"OUTCOME\") (:content *comp*)))" "(map :tag (filter (match % \"OUTCOME\") (:content *comp*)))" "(map :tag (filter #(= (:tag %) :DICH_OUTCOME) (:content *comp*)))" "(map :tag (filter (match :tag \"OUTCOME\") (:content *comp*)))" "(map :tag (filter #(= (:tag %) :OUTCOME) (:content *comp*)))" "(map :tag aa)" "(count aa)" "(def aa (filter map? (:content *comp*)))" "(count aa)" "(def aa (html/select *comp*  [:OUTCOME]))" "(def aa (html/select *comp  [:OUTCOME]))" "(def aa (html/select *comp) [:OUTCOME])" "(def aa (html/select *comp) {:OUTCOME})" "(extract-comparison-data *comp* 0)" "(extract-comparison-data *comp*)" "(map :tag *comparisons*)" "(first *comparisons*)" "(count *comparisons*)" "(count comparisons)" "(*comparisons*)" "(comparisons)" "(get-labels *outcome*)" "(keywords->lower [:ADAD :SGSG :EHEH])" "(map #(-> % name clojure.string/lower-case keyword) [:GROUP_LABEL_1 :GROUP_LABEL_2
                 :GRAPH_LABEL_1 :GRAPH_LABEL_2
                 :EFFECT_MEASURE])" "(map #(-> % name clojure.string/lower-case) [:GROUP_LABEL_1 :GROUP_LABEL_2
                 :GRAPH_LABEL_1 :GRAPH_LABEL_2
                 :EFFECT_MEASURE])" "(map #(clojure.string/lower-case (name %)) [:GROUP_LABEL_1 :GROUP_LABEL_2
                 :GRAPH_LABEL_1 :GRAPH_LABEL_2
                 :EFFECT_MEASURE])" "(clojure.string/lower-case (name :HELLO))" "(clojure.string/lower-case \"Hello\")" "(clojure.string/lower-case \"hello\")" "((map #(clojure.string/lower-case (name %)) [:GROUP_LABEL_1 :GROUP_LABEL_2
                 :GRAPH_LABEL_1 :GRAPH_LABEL_2
                 :EFFECT_MEASURE]))" "((map #(clojure.string/to-lower (name %)) [:GROUP_LABEL_1 :GROUP_LABEL_2
                 :GRAPH_LABEL_1 :GRAPH_LABEL_2
                 :EFFECT_MEASURE]))" "((map #(-> % name clojure.string/lower-case) [:GROUP_LABEL_1 :GROUP_LABEL_2
                 :GRAPH_LABEL_1 :GRAPH_LABEL_2
                 :EFFECT_MEASURE]))" "(doseq(-> (map name [:GROUP_LABEL_1 :GROUP_LABEL_2
                 :GRAPH_LABEL_1 :GRAPH_LABEL_2
                 :EFFECT_MEASURE]) clojure.string/lower-case))" "(doall(-> (map name [:GROUP_LABEL_1 :GROUP_LABEL_2
                 :GRAPH_LABEL_1 :GRAPH_LABEL_2
                 :EFFECT_MEASURE]) clojure.string/lower-case))" "(-> (map name [:GROUP_LABEL_1 :GROUP_LABEL_2
                 :GRAPH_LABEL_1 :GRAPH_LABEL_2
                 :EFFECT_MEASURE]) clojure.string/lower-case)" "(-> (map name [:GROUP_LABEL_1 :GROUP_LABEL_2
                 :GRAPH_LABEL_1 :GRAPH_LABEL_2
                 :EFFECT_MEASURE]) clojure.string/to-lower)" "(-> (map name [:GROUP_LABEL_1 :GROUP_LABEL_2
                 :GRAPH_LABEL_1 :GRAPH_LABEL_2
                 :EFFECT_MEASURE]))" "(-> (map name [:GROUP_LABEL_1 :GROUP_LABEL_2
                 :GRAPH_LABEL_1 :GRAPH_LABEL_2
                 :EFFECT_MEASURE)])" "(->> [:GROUP_LABEL_1 :GROUP_LABEL_2
                 :GRAPH_LABEL_1 :GRAPH_LABEL_2
                 :EFFECT_MEASURE] #(map name %))" "(-> [:GROUP_LABEL_1 :GROUP_LABEL_2
                 :GRAPH_LABEL_1 :GRAPH_LABEL_2
                 :EFFECT_MEASURE] #(map name %))" "(keyword \"keyword\")" "(get-labels *outcome*)" "(keys *data*)" "(keys *comp*)" "(get-labels *outcome*)" "(test [:d :e :a :b :c] [:a :b :c])" "(remove (build-or first-columns) [:d :a :b :c])" "(filter (build-or first-columns) [:d :a :b :c])" "(test [:d :e :a :b :c] [:a :b :c])" "(filter (build-or first-columns) [:d :a :b :c])" "(build-or first-columns)" "(doc some)" "(macroexpand '(apply some [:a :b :c]))" "(apply some [:a :b :c])" "(reduce some [:a :b :c])" "(apply some [:a :b :c])" "(some [:a :b :c])" "((build-or first-columns) :a)" "(filter (build-or first-columns) [:a :b :c :d])" "(build-or first-columns)" "(build-or [:a :b :c])" "(bo first-columns)" "(for [i first-columns] (list = :a i))" "(for [i first-columns] '(= :a ~i))" "(for [i first-columns] '(= :a i))" "(for [i first-columns] '(= [:a] i))" "first-columns" "#(for [i first-columns] '(= % i))" "(build-or first-columns)" "(build-or [:a :b :c])" "(macroexpand '(bo [:a :b :c])) " "(bo [:a :b :c])" "(bo first-columns)" "first-columns" "(bo [:a :b :c])" "(build-or [:a :b :c])" "(macroexpand (build-or [:a :b :c]))" "(build-or first-columns)" "(filter (build-or [:comparison :outcome])  (keys (first rev-data)))" "(build-or [:a :b :c])" "(filter (build-or [:comparison :outcome])  (keys (first rev-data)))" "(filter (build-or first-columns)  (keys (first rev-data)))" "((build-or [:a :b :c]) :a)" "((build-or [:a :b :c]) 1)" "(build-or [:a :b :c])" "(macroexpand '(build-or [:a :b :c]))" "(macroexpand build-or)" "(build-or [:a :b :c])" "(concat [1 2 3] [4 5 6])" "(join [1 2 3] [4 5 6])" "(vec [1 2 3] [4 5 6])" "(conj [1 2 3] [4 5 6])" "(cons [1 2 3] [4 5 6])" "(vector [1 2 3] [4 5 6])" "(filter #(or (= :outcome %) (= :comparison %) (= :subgroup %)) (keys (first rev-data)))" "(filter #(or (= :outcome %) (= :comparison %)) (keys (first rev-data)))" "(filter #(or (:outcome %) (:comparison %)) (keys (first rev-data)))" "(filter #((or (:outcome %) (:comparison %))) (keys (first rev-data)))" "(keys (first rev-data))" "(write-csv \"h\" rev-data)" "(doc mapv)" "(use 'clojure.repl)" "(doc mapv)" "(sorted-map (keys (first rev-data)))" "(keys (first rev-data))" "(keys rev-data)" "rev" "(slurp \"data/rm6.rm5\")" "(dl/parse-enlive (slurp \"data/rm6.rm5\"))" "(count rev)" "(get-labels *outcome*)" "(map #(count (keys %)) rev)" "(merge (zipmap [:a :b :c] (repeat \"\")) {:a 1})" "(zipmap [:a :b :c] (repeat \"\"))" "(zipmap [:a :b :c] (repeat 1))" "(zipmap [:a :b :c] 1)" "(keys (apply merge rev))" "(apply merge rev)" "(revman-data (slurp \"data/rm6.rm5\"))" "(extract c)" "(second rev)" "(first rev)" "rev" "(first rev)" "(extract *comp*)" "(doc merge)" "(use 'clojure.repl)" "(use clojure.repl)" "(merge (get-labels *outcome*) {:a 1 :b 2} {:c 5 :d 6})" "(merge (get-labels *outcome*) {:a 1 :b 2})" "(get-labels *outcome*)" "(zipmap [:a :b :c] [1 2 3])" "(get-labels *outcome*)" "(html/select *outcome* [[:GROUP_LABEL_1] [:GROUP_LABEL_2]])" "(html/select *outcome* [[:GROUP_LABEL_1]])" "(html/select *outcome* [:GROUP_LABEL_1])" "(map #(match % \"label\") (:content *outcome*))" "(keys (:content *outcome*))" "(map #(match % \"label\") (:content *outcome*))" "(map #(match % \"label\") (:content *outcome))" "(extract *comp*)" "(name \"Hello\")" "(:attrs *outcome*)" "(:tag *outcome*)" "(html/select *outcome* [])" "(extract c)" "(count c)" "(extract aa)" "(map count aa)" "(map :tag aa)" "(count aa)" "(extract *comp*)" "(#(second (re-find #\"([A-Z]+)_\" (name %))) :DICH_DATA)" "#(second (re-find #\"([A-Z]+)_\" (name %)))" "(second (re-find #\"([A-Z]+)_\" \"DICH_SUBGROUP\"))" "(re-find #\"([A-Z]+)_\" \"DICH_SUBGROUP\")" "(re-find #\"([A-Z]+)(_)\" \"DICH_SUBGROUP\")" "(re-find #\"([A-Z]+)_\" \"DICH_SUBGROUP\")" "(re-find #\"([A-Z+)_\" \"DICH_SUBGROUP\")" "(re-find #\"(.+)_\" \"DICH_SUBGROUP\")" "(re-find #\"([A_Z]+)_\" \"DICH_SUBGROUP\")" "(re-find #\"(.)+(_)\" \"DICH_SUBGROUP\")" "(re-find #\"(.)+_\" \"DICH_SUBGROUP\")" "(re-find #\"(.)_\" \"DICH_SUBGROUP\")" "(extract *comp*)" "(re-pattern \"Hello\")" "(#((complement nil?) (re-find %2 (name %1))) :DICH_DATA #\"DATA\")" "(#((complement nil?) (re-find %2 (name %1) :DICH_DATA #\"DATA\")))" "(->> (re-find #\"DATA\" (name :DICH_DATA)) (complement nil?))" "(-> (re-find #\"DATA\" (name :DICH_DATA)) (complement nil?))" "(re-find (name #\"DATA\" :DICH_DATA) )" "(-> (name :DICH_DATA) (partial (re-find #\"DATA\")) )" "(->> (name :DICH_DATA) (partial (re-find #\"DATA\")) )" "(->> (name :DICH_DATA) (re-find #\"DATA\" %) )" "(->> (name :DICH_DATA) #(re-find #\"DATA\" %) )" "(-> (name :DICH_DATA) #(re-find #\"DATA\" %) )" "(-> (name :DICH_DATA) #(re-find #\"DATA\") )" "(match )" "((complement nil?) \"Hello\")" "(nil? \"Hello\")" "(true? \"Hello\")" "(true? nil)" "(re-find #\"DATAw\" (name :DICH_DATA) )" "(re-find #\"DATA\" (name :DICH_DATA) )" "(re-find (name #\"DATA\" :DICH_DATA) )" "(name :hello)" "(source name)" "(extract *comp*)" ";
(filter identity (flatten  (extract *comp* 0 0 0)))" "(filter identity (flatten  (extract *comp* 0 0 0)))" "(extract *comp* 0 0 0) " "(-> (html/select *subgroup*
					 [:NAME])
                           first :content first)" "(-> (html/select *data*
					 [:NAME])
                           first :content first)" "(-> (html/select *outcome*
					 [:NAME])
                           first :content first)" "name" "(:tag *subgroup*)" "(vector {:a 1} {:b 2})" "(vec {:a 1} {:b 2})" "(list {:a 1} {:b 2})" "(conj {:a 1} {:b 2})" "(cons {:a 1} {:b 2})" "(cons {:a} {:b})" "*data*" "(keys  *data*)" "(:content  *data*)" "(:attrs  *data*)" "(:tag *data*)" "(:tag (-> *subgroup* :content second))" "(:tag (-> *subgroup* :content first))" "(:tag (-> *subgroup* :content ))" "(:tag (-> :attrs *subgroup* :content ))" "(:tag (-> :attrs *subgroup* :content second ))" "(:tag (-> :attrs *subgroup* :content first ))" "(:attrs *subgroup*)" "(-> (html/select *subgroup* [:NAMEd]))" "(-> (html/select *subgroup* [:NAME]))" "(:content *subgroup*)" "(:attrs *subgroup*)" "*subgroup*" "(keys *subgroup*)" "(:attrs *subgroup*)" "(nth (filter identity (flatten  (extract *comp* 0 0 0))) 1)" "(filter identity (flatten  (extract *comp* 0 0 0)))" "(nth (flatten  (extract *comp* 0 0 0)) 5)" "(nth (flatten  (extract *comp* 0 0 0)) 4)" "(nth (flatten  (extract *comp* 0 0 0)) 3)" "(nth (flatten  (extract *comp* 0 0 0)) 2)" "(nth (flatten  (extract *comp* 0 0 0)) 1)" "(nth (flatten  (extract *comp* 0 0 0)) 0)" "(flatten  (extract *comp* 0 0 0))" "(nth (extract *comp* 0 0 0) 3)" "(nth (extract *comp* 0 0 0) 2)" "(nth (extract *comp* 0 0 0) 1)" "(nth (extract *comp* 0 0 0) 0 )" "(extract *comp* 0 0 0) " "(extract *comp 0 0 0) " "(:attrs *comp*)" "(assoc(:attrs *outcome*) {:pants 1 :arse 2})" "(merge (:attrs *outcome*) {:pants 1 :arse 2})" "(:attrs *outcome*)" "(-> (html/select *outcome* [:NAME]) first :content first)" "(-> (html/select *comp* [:NAME]) first :content first)" "(-> (html/select *comp* [:NAME]) first :content)" "(-> (html/select *comp* [:NAME]) first :tag)" "(-> (html/select *comp* [:NAME]) first)" "(first (html/select *comp* [:NAME]))" "(html/select *comp* [:NAME])" "(-> *comp* :content first)" "(:tag (nth  (filter  map? (-> *outcome* :content)) 5))" "(nth  (filter  map? (-> *outcome* :content)) 5)" "(nth  (filter  map? (-> *outcome* :content)) 4)" "(nth  (filter  map? (-> *outcome* :content)) 3)" "(second  (filter  map? (-> *outcome* :content)))" "(first  (filter  map? (-> *outcome* :content)))" "(second (filter  map? (-> *outcome* :content)))" "(filter  map? (-> *outcome* :content))" "(map map? (-> *outcome* :content))" "(:tag (->> *outcome* :content  #(nth % 3)))" "(:tag (->> *outcome* :content  #(nth % 2)))" "(:tag (->> *outcome* :content  #(nth 2 %)))" "(:tag (-> *outcome* :content  #(nth 2 %)))" "(:tag (-> *outcome* :content  #(nth % 2)))" "(:tag (-> *outcome* :content  second))" "(:tag (-> *outcome* :content  first))" "(:tag (-> *outcome* :content  ))" "(:content *outcome*)" "(:tag (-> *outcome* :content  second :content))" "(:tag (-> *outcome* :content  first :content))" "(:tag (-> *outcome* :content  rest rest first))" "(:tag (-> *outcome* :content  rest first))" "(:tag (-> *outcome* :content  first))" "(:tag (-> *outcome* :content  #(nth % 1)))" "(:tag (-> *outcome* :content  #(nth % 2)))" "(:tag (-> *outcome* :content  first))" "(:tag (-> *outcome* :content  second))" "(:tag (-> *outcome* second :content))" "(:tag *outcome*)" "(:tag (second cc1))" "(:tag (first cc1))" "cc1" "(:tag cc1)" "(:tag c1)" "(let [{:keys [tag attrs content]} c1] tag)" "(let [{keys [tag attrs content]} c1] :tag)" "(let [{keys [:tag :attrs :content]} c1] tag)" "(keys c1)" "(let [{keys [tag attrs content]} c1] tag)" "(:tag c1)" "(let [{keys [:tag :attrs :content]} c1] tag)" "(let [{keys [tag attrs content]} c1] tag)" "(seq? (:content c1))" "(seq? c1)" "(seq c1)" "(seq? (:content c1))" "(first (:content c1))" "(first (content c1))" "(:attrs c1)" "(:tag c1)" "(:tag [1 2 3])" "(extract c1 0 0 0)" "(:tag (first cc1))" "(rest cc1)" "(first cc1)" "(extract c1 0 0 0)" "(:tag c1)" "(-> (first cc1) :content first)" "(-> (first cc1) :content)" "(first cc1)" "(class cc1)" "(map :tag cc1)" "(map :tag (first cc1))" "(map :tag first cc1)" "(first cc1)" "cc1" "(filter map? (:content c1))" "(first (:content c1))" "(keys (:content c1))" "(:content c1)" "c1" "cc1" "(:content c1)" "(:content cc1)" "(apply dissoc (:content c1)  [:DICH_OUTCOME  :DICH_DATA])" "(apply dissoc {:a 1 :b 2 :c 3 :d 4}  [:a :b])" "((complement select-keys) {:a 1 :b 2 :c 3 :d 4}  [:a :b])" "(select-keys {:a 1 :b 2 :c 3 :d 4}  [:a :b])" "(select-keys {:a 1 :b 2 :c 3 :d 4} :a :b)" "(get {:a 1 :b 2 :c 3 :d 4} :a :b)" "(class c1)" "(:attrs c1)" "(:tag c1)" "c1" "cc1" "cmp " "cmp" "(flatten c1)" "(tree-seq map? identity c1)" "(tree-seq map? identity (filter map? c1))" "(tree-seq seq? identity (filter map? c1))" "(tree-seq seq? identity c1)" "(tree-seq seq? c1)" "(tree-seq c1)" "(:attrs  (second (filter map? (:content c1))))" "(:tag (second (filter map? (:content c1))))")